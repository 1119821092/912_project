# References

[考研英语真题词汇的统计分析](https://github.com/YSMull/words-statistics)

[关于清华计算机专业基础综合（912）的复习](https://xuanxuanblingbling.github.io/life/study/2018/12/29/)

[2017年清华大学计算机科学与技术系考研小结](https://blog.csdn.net/chr1991/article/details/64971113)

[T大在线编程题汇总](https://www.nowcoder.com/kaoyan/retest/1001)

# 考点整理

> ~~此处容易**<font color=red>过拟合</font>**。~~
>
> 小题1颗★，大题3颗★。

## 数据结构

| 考点                       | 2019   | 2018  | 2017   | 2016 |
| -------------------------- | :----- | :---- | :----- | :--- |
| BBST（红黑/AVL/Splay/B树） | ★★     | ★★★★  | ★★     | ★★   |
| 散列表                     | ★      | ★★    | ★      | ★★★  |
| 二叉树遍历/PFS             | ★★★★★★ |       | ★★★★★★ | ★★★×3 |
| 排序（冒/插/选/基/归/锦/败、CBA） | ★★★★★  | ★★    | ★★★★   | ★★ |
| 串匹配（KMP/BM）           | ★★     | ★★    | ★      |      |
| 复杂度                     | ★      | ★★    | ★      |      |
| 编码树（Huffman/PFC）      | ★      | ★     | ★      |      |
| RPN                        | ★      | ★     | ★      |      |
| 减治                       |        | ★★★   |        | ★★★ |
| Catalan                     | ★      |       | ★      |      |
| 堆（完全、左式堆）            | ★      | ★★    |        |      |
| 栈（调用栈、栈混洗）    | ★      |       |        | ★    |
| Dijkstra算法               | ★      |       |        | ★    |
| 二分、Fib查找              |        | ★★★★★ |        |      |
| 最小生成树（Prim） |        |       |        | ★★★  |
| 非法表达式                 |        | ★     |        |      |
| 逻辑地址                   |        |       |        | ★    |

## 操作系统

| 考点 | 2019 | 2018 | 2017 | 2016 |
| ---- | :--: | :--: | :--: | :--: |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |

## 计算机原理

| 考点 | 2019 | 2018 | 2017 | 2016 |
| ---- | :--: | :--: | :--: | :--: |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |

## 计算机网络

| 考点 | 2019 | 2018 | 2017 | 2016 |
| ---- | :--: | :--: | :--: | :--: |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |

# 真题

## 2019

{% pdf 清华2019.pdf %}

### 数据结构

#### 判断题

##### 复杂度

判断：$n^{logloglogn}=O(\lfloor logn\rfloor!)$

> 令$t=logn$，则
> $$
> \begin{split}
> n^{logloglogn}=\left[{\color{red}{ {(2^t)}^{loglogt} } } \gg2^t\right] \,\,\,&{\color{blue}{ ?} }\,\,\,\,\,
> \,\,\,\,\,\,\,O({\color{red}{ t!} })=O(\lfloor t\rfloor!)=O(\lfloor logn\rfloor!)\\
> 指数置换：{(2^{loglogt})}^{t}={(logt)}^t \,\,\,&{\color{blue}{ ?} }\,\,\,\,\,\,t!\\
> 取对数：\,\,\,\,\,\,\,tloglogt \,\,\,\,\,&{\color{blue}{?} }\,\,\,\,\,\,log(t!)=(0+log2+...+logt)\\
> 放缩：\,\,\,\,\,\,\,tloglogt \,\,\,\,\,&{\color{blue}{\ll} }\,\,\,0.5tlogt（凸函数放小为线性然后求和）\\
> \Longrightarrow\,\,\,\,\,\,\,tloglogt\,\,\,\,\,&{\color{blue}{\ll} }\,\,\,  0.5tlogt<log(t!)\\
> \Longrightarrow\,\,\,\,\,\,\,tloglogt\,\,\,\,\,&{\color{blue}{=} }\,\,\,  O(log(t!))
> \end{split}
> $$
> ~~QAQ~~Q.E.D，命题为**<font color=red>真</font>**。
>
> > 如果没有阶乘号的话，有：$\forall \epsilon>0, logn=O(n^{\epsilon})$。（细枝末节不影响复杂度）参见*习题解答-1-9*。
> >
> > 又有：$log1+log2+...+logn=log(n!)=\Theta(nlogn)\Longleftrightarrow n!=\Theta(n^n)$，参见*课件P52-对数级数*。
> >
> > - 由此可得到更简洁的证明方法：
> >
> > $$
> > \begin{split}
> > n^{logloglogn}=\left[{\color{red}{ {(2^t)}^{loglogt} } } \gg2^t\right] \,\,\,&{\color{blue}{ ?} }\,\,\,\,\,
> > \,\,\,\,\,\,\,O({\color{red}{ t!} })=O(\lfloor t\rfloor!)=O(\lfloor logn\rfloor!)\\
> > 指数置换：{(2^{loglogt})}^{t}={(logt)}^t \,\,\,&{\color{blue}{ ?} }\,\,\,\,\,\,t!\\
> > {(logt)}^t=O(t^t)&=O(t!)
> > \end{split}
> > $$
> >
> > **原题**：参见*具体数学-P410-热身题-9.2-b*（推荐练习一波）
> >
> > - 哪个函数增长得快：$n^{\ln\ln\ln n}还是(\ln n)!$？
> >   - 原题解析：$n^{\ln\ln\ln n}\ll (\ln n)!\ll n^{\ln\ln n}$.（~~就只有这么一点orz~~）

##### Huffman编码

判断：交换哈夫曼树的不同深度的节点，编码长度必然改变

> 特殊：考虑一个**所有节点的频率相同**的情况，那么任意交换节点编码长度不变。
>
> 因此问题转化为：***不同深度的节点是否频率一定不同？***
>
> 构造反例：（3个频率相同的节点）
>
> ![1551612046084](README/1551612046084.png)
>
> Q.E.D，命题为**<font color=blue>假</font>**。

##### KMP算法

判断：即使不使⽤改进的 next 表，kmp 依然可以达到线性的时间复杂度

> 此为书上原话，P315页11.3.8节”继续改进“-第一段：*尽管以上KMP算法已可保证线性的运行时间，但在某些情况仍有进一步改进的余地。*11.3.7节则给出了线性复杂度的性能分析。
>
> Q.E.D，命题为**<font color=red>真</font>**。

##### Splay树

判断：对于不符合局部性原理的访问，splay 的分摊复杂度不是 $O(logn)$

> 对于规模为任意n的（**逐层**）伸展树，只要按关键码单调的次序，周期性地反复进行查找，则无论总的访问次数m>>n有多大，就分摊意义而言，每次访问都将需要o(n)时间。
>
> Q.E.D，命题为**<font color=red>真</font>**。
>
> > 参见*教材-8.1.2最坏情况-P204*（注意这个是逐层伸展才这样，**双层**策略（含羞草）则可以保证 $O(logn)$）
> >
> > 这里的局部性原理是指：刚被访问的数据（附近），极有可能很快被**再次**访问。

##### 二叉树重构

判断：对于⼆叉树，通过先序遍历和后序遍历不能确定其层次遍历

> 首先考虑问题：`先序+后序`是否唯一确定二叉树？（并不能）
>
> - 问题的证明可参考：[*MOOC-二叉树-重构-3*](https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/courseware/16d8402a24fd4429a8a7cc1c8401cb1f/b3fdcad4c3a84a8a861003eaa8b5965c/)
>   - (先序|后序)+中序
>   - **(先序+后序)&&真二叉树**
>
> 对于真二叉树，先序+后序对应唯一二叉树，显然成立。
>
> 对于非真二叉树：
>
> - 给定确定的先序和后序序列，需要考虑两个序列同时固定时，二叉树能发生怎么样的变化。
> - 只有孩子为1个的节点才可能发生变化。（单个孩子先序和后序遍历的结果一致）
>   - 左孩子$\longrightarrow$**<font color=purple>右孩子</font>**
>   - **<font color=purple>左孩子</font>**$\longleftarrow$右孩子
> - 因为**变化在同一层且不发生位置交换**，所以层次遍历也不变
>
> ![1551627410744](README/1551627410744.png)
>
> Q.E.D，命题为**<font color=blue>假</font>**。先序+后序**能确定**层次遍历。
>
> **解法2**：（递归生成法）
>
> - 任意给定先序序列和后序序列（`V[root], L[left], R[right]`）
> - 先序：`VL****R****`；后序：`****L****RV`
>   - 有两个孩子？
>     - 局部等价于真二叉树
>     - 确定层次遍历`VLR********`
>     - 递归`L****`和`R****`
>   - 只有一个孩子？
>     - 退化为`VL****`和`****LV`（特判一下两个序列的第2个和倒数2个元素是否相同）
>     - 确定层次遍历`VL****`
>     - 递归`L****`
> - 因为可以递归生成唯一的层次遍历，显然就确定了层次遍历序列
>
> > [先序遍历和后序遍历为什么不能唯一地确定一棵树？](https://blog.csdn.net/GYQJN/article/details/52709912)

##### Catalan数

判断：对于叶节点为 2019 的真⼆叉树，其数量**⼩于** 2018 对括号所组成的合法表⽰式数量

> 叶节点为 2019 的真⼆叉树的个数 = $C_{2018}$。
>
> 2018 对括号所组成的合法表⽰式数量 =  $C_{2018}$。两者相等。
>
> Q.E.D，命题为**<font color=blue>假</font>**。
>
> > [**卡特兰数— 计数的映射方法的伟大胜利**| Math173](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=9&ved=2ahUKEwjWqJiesubgAhXwwosBHSnACLEQFjAIegQIBhAB&url=http%3A%2F%2Flanqi.org%2Finterests%2F10939%2F&usg=AOvVaw0FIR5VllhrOlM-_DNiqnfz)
> >
> > [【卡特兰数】有N对括号，输出所有合法的组合](https://blog.csdn.net/ffmpeg4976/article/details/42340379)
> >
> > [从《编程之美》买票找零问题说起，娓娓道来卡特兰数——兼爬坑指南](https://www.cnblogs.com/wuyuegb2312/p/3016878.html)

##### 层次遍历

判断：对于叶节点数量为 2018 的⼆叉树，层次遍历队列容量必然⼩于 2018

> 层次遍历队列的容量应该不小于最大的某一层的元素数。
>
> 2018的叶节点的二叉树，一层的元素数最大可以**等于**2018。（不能大于）
>
> ![1551625281642](README/1551625281642.png)
>
> Q.E.D，命题为**<font color=blue>假</font>**。
>
> > 相似题目：*习题解答-5-18*
> >
> > - 设二叉树共含n个节点，则辅助队列的容量应该不低于n/2。
> >
> > 层次遍历的每一步都对应着一个二叉树（原二叉树的子二叉树）。
> > 给定二叉树，所有的[层次遍历子二叉树]中叶子节点的最大值就是队列最小容量。
> >
> > **任何遍历过程都对应着树的一种生长模式**。
>
> 注：本题在2014年期中试卷3-2上出现，稍微不同。
>
> ![1567349236370](README/1567349236370.png)

##### *插入排序

判断：插⼊排序每次插⼊数据，即使不增加循环节，也不⾄减少

> 问的是循环节的个数。
>
> - 对于任意一个有序前缀，插入排序后循环节数目不变。（显然）
> - <font color=red>`总循环节数` = `元素归位数` + `非归位循环节数`</font>。
>
> 构造反例：`6 5 4 3 2 1`（逆序列）
>
> - 初始有3个循环节
>
> ![1552136122748](README/1552136122748.png)
>
> Q.E.D，命题为**<font color=blue>假</font>**。
>
> > 相似题目：*习题解答-3-14*（**选择排序**循环节）
> >
> > ![1552136806707](README/1552136806707.png)

##### 逆序对

判断：交换两个逆序对，必然会减少总逆序对数

> 认为题意是`交换构成逆序对的两个元素`。
>
> 首先给出引理：
>
> - 左端点降低，或右端点升高，逆序对总数一定不增。（这是显然的）
>
> 交换逆序对的过程可以等价转化为：（逆序对区间外的逆序是不受影响的，因此可以只分析内部区间）
>
> ![1551802587240](README/1551802587240.png)
>
> 又注意到，在上述过程（两个`不增变换`）完成后，端点不再构成逆序对。
>
> - 因为不增，所以只要出现了下降，就一定会保持。
>
> 因此，交换逆序对后，总逆序对数至少减少1个。
>
> Q.E.D，命题为**<font color=red>真</font>**。

##### 基数排序

判断：如果基数排序底层采⽤不稳定的算法，那么得到的结果可能是不正确的

> 因为排序是按位**`多步`排序**，必须保证下一次的排序不影响上一次的排序结果。
>
> 如果底层不稳定，那么很可能导致之前排序的结果丢失。（每次只关注某一位）
>
> Q.E.D，命题为**<font color=red>真</font>**。
>
> > 参考：*算法导论-8-3-基数排序*

##### *函数调用栈

判断：函数的调⽤栈中如果有相同的函数，则他们必然紧邻

> 考虑循环调用：（显然不必紧邻）
>

```c++
int a(){ return b();}
int b(){ return a();}
int main(){ a();}
```

> Q.E.D，命题为**<font color=blue>假</font>**。
>
> > 参考：*教材-4.2.1-函数调用栈*

##### 堆

判断：如果插⼊的关键码独⽴均匀分布，堆的插⼊操作平均O(1)

> 认为题目问的是完全二叉堆。
>
> 由于完全二叉堆插入采用上滤操作，并且每一层的节点数是指数型的，因此若完全随机地插入，则只期望上升1层。
>
> Q.E.D，命题为**<font color=red>真</font>**。
>
> > 参考：*习题解答-10-6*

#### 简答题

##### 逆波兰表达式

逆波兰表达式的优点？既然中缀转换为逆波兰就需要可以计算出表达式值，那**逆波兰意义何在**？

> RPN的运算符优先级表述能力强，计算效率高。
>
> 意义如下：（因为转换表达式只需一次，而求值可能多次）
>
> ![1561884731840](README/1561884731840.png)
>
> 参考：*教材-4.3.4-逆波兰表达式-P97*

##### DFS

DFS 中何时标记前向边？何时标记后向边？

> 前向边：从祖先指向后代。
>
> 后向边：从后代指向祖先。
>
> > RT所示。
>
> ![1561882924278](README/1561882924278.png)

##### 败者树

相⽐锦标赛排序，败者树的优势是？

> 重赛过程中不必在左右子树之间来回访问内存，时间效率高。
>
> 参考：*PPT-P1181*

##### BBST

试举出红⿊树优于 AVL 树的场景，红⿊树相⽐ AVL 树的优势

> AVL树需要维护平衡因子，而红黑树仅需要对节点重染色。
>
> 在删除操作中，AVL树需要$O(logn)$次旋转，而红黑树的重染色分摊复杂度仅O(1)，并且拓扑结构的重构也只需O(1)。红黑树在持久性、历史版本的维护上具有优势。
>
> > 参考：*教材-8.3-红黑树-P227*，*PPT-P824、P861*

##### 散列表

相⽐开散列，闭散列的优势，试举例说明两点。

> 单独开辟一块**连续**空间，可充分利用系统缓存，提升访存效率。（局部性）
>
> 结构**简单**，算法易于实现，不易出错。
>
> > 参考：*PPT-P1034*，*教材-9.3.6-闭散列策略-P268*

##### 排序

相⽐选择排序，插⼊排序的优势，试举例说明两点。

> RT。就地、在线、输入敏感。
>
> ![无题](README/无题.png)
>
> > 参考：*PPT-P275*

##### Dijkstra算法

对于稠密图，迪杰斯特拉应该使⽤多叉堆替换⼆叉堆，为什么？多叉堆分叉数 m 怎么确定？

> RT。
>
> ![无题](README/无题(2)-1561887177730.png)
>
> ![无题](README/无题(1)-1561886854814.png)
>
> > 参考：*PPT-P1185、P1187*

##### KMP算法

在何种情形下,KMP 优于蛮⼒算法，为什么？

> 单次匹配概率越大（字符集越小）的场合，KMP的优势越明显；否则与蛮力算法的性能相差无几。
>
> 参考：*PPT-P1262*

#### 算法题

##### 后序k遍历

返回后序遍历的第 K 个节点，时间复杂度不超过树 x 的深度，$Ο(depth(𝑥))$

```c++
struct BinNode{
    int size; //当前节点和孩⼦总数
    BinNode *lchild,*rchild;
};
BinNode *rank(BinNode* t, int k){
    //有效代码⾏数不超过 12 ⾏
    //不要尝试模拟后序遍历，时间复杂度会超时。
}
```

⼀，给出具体算法实现。

> 快速选取算法

```c++
BinNode *rank(BinNode* t, int k){
    if(t->size == k) return t;
    if(t->lchild->size < k)
        return rank(t->rchild, k - t->lchild->size);
    else
        return rank(t->lchild, k);
}
```

> 尾递归改写

```c++
BinNode *rank(BinNode* t, int k){
    while(t->size != k){
        if(t->lchild->size < k){
            t = t->rchild;
            k -= t->lchild->size;
        } else{
            t = t->lchild;
        }
    }
    return t;
}
```

⼆，解释你的算法。

> 参考快速选取算法。*教材12.2-选取与中位数*

三，分析时间复杂度和空间复杂度。

> 不变性：算法每步必定下降一层，递归深度不超过$Ο(depth(𝑥))$。
>
> 时间复杂度：$Ο(depth(𝑥))$。
>
> 空间复杂度：$Ο(depth(𝑥))$。（调用栈大小，迭代版则可以达到O(1)就地）
>
> > 迭代改写参考*习题解答-12-6* ~~（滑稽~~

### 操作系统

#### 填空题

##### *stride调度算法

(1) stride调度算法中，进程分配时间和其优先级成反⽐，优先级越低进程上CPU运⾏的时间就会更长，⽤⼋位⽆符号数来表⽰进程A的运⾏时间有可能会溢出，但是当步长s [1] 127时，只要做⼩⼩的技巧就仍可以正确判断时间，然后又引⼊进程B，a为A的stride，b为B的stride，当sign(a-b) [2] 时说明A正在运⾏，此时a+s [3] 256，当sign(a+s-b) [4] 0时，轮到B运⾏。

> 源自ucore lab6。实验指导书P287。
>
> [1]：`>`（表示溢出），[2]：，[3]：，[4]：。

##### x86特权级

(2)CPL<=DPL[门]和CPL>=DPL[段]， [5] 表⽰请求时可以和门特权级相同， [6] 表⽰请求时应低于段的特权级。

> [5]：CPL<=DPL[门]，[6]：CPL>=DPL[段]。PPT上有。~~猜也能猜出来~~。

##### 进程

(3)⽗进程先退出，还未退出的⼦进程被称为 [7] 。⼦进程退出时，其⽗进程还没wait，此时⼦进程被称为 [8] 。

> 孤儿进程，僵尸进程。
>
> ![1567020792909](README/1567020792909.png)
>
> >  https://www.cnblogs.com/Anker/p/3271773.html
>
> 似乎没有在课上提到。

##### 信号量

(4)

```
class Semaphore {
int sem;
WaitQueue q;
}
Semaphore::P() {
[9] ;
if ( [10] ) {
Add this thread t to q;
block(t);
}
}
Semaphore::V() {
[11] ;
if ( [12] ) {
Remove a thread t from q;
wakeup(t);
}
}
```

##### x86硬件

(5) x86-32CPU的硬件组成，CR3寄存器⽤于存储页⽬录表起始 [13] 。

##### 文件系统（硬链接、软链接）

(6)A是计数为1的⽂件，创建A的硬链接B，再创建A的软连接C，再创建B的硬链D，B计数 [14] , D计数 [15] 。

#### 判断题

##### *x86 页表细节

(1) x86开启了⼆级页表，则⼀级页表可以不在内存中。

##### *ucore 时钟中断

(2)ucore时钟中断为10ms，故不能完成 10ms以下的定时。

##### *中断向量表

(3)中断向量表中存放着中断门的优先级。

##### 死锁

(4)不安全状态就是死锁状态

> 错。MOOC上讲过。死锁是不安全的真子集。

##### *线程

(5)只有⼀个main函数的程序不能有多个线程

#### *UCORE（页表）

![1567013300666](README/1567013300666.png)

#### *内存分析（逻辑地址转换）

给了段内存的 dump，以及⼀些页表项的信息，分析 A、B 进程的逻辑地址转换

### 组成原理

#### 选择题

##### 磁盘

(1)下列哪⼀项没有容错能⼒
A. RAID0 B. RAID1 C. RAID5 D. RAID6

> A。OS里面讲过。RAID0只是增加了访问带宽，自然没有容错能力。

##### RAM

(2)下列关于静态存储器和动态存储器的描述正确的是
A.静态存储器使⽤触发器，需要定期刷新
B.静态存储器使⽤电容，不需要定期刷新
C.动态存储器使⽤触发器，不需要定期刷新
D.动态存储器使⽤电容，需要定期刷新

> D。常识。

##### 虚存

(3)下列哪个是对的
A．虚拟内存空间⽐实际的地址空间⼤
B．虚拟内存空间⽐实际的地址空间⼩
C．虚拟内存空间连续存放，实际内存⼀定连续存放
D．虚拟内存空间不连续存放，实际内存有可能连续存放

> D。注意是实际的**地址**空间。虚拟内存空间应该等于实际的地址空间。而虚拟存储只是在物理的非连续内存分配（段、页机制）的基础上增加调换功能。

##### 总线

(4)下⾯总线说法哪个正确（）
A.并⾏总线速度⼤于串⾏
B.异步总线速度⼤于同步
C.单总线速度⼤于双总线
D.以上说法均错误

> A。同步总线的特点有高速，单总线的特点是慢。见PPT。
>
> **可能是D**？之前408考试不是说还跟频率有关吗？并行不支持太高频。

##### 流水线

(5)MIPS 五级流⽔中，有哪个数据冲突（）
A.RAR B.RAWC.WARD.WAW

> B。写后读RAW。（可以记成一个单词：raw）

#### 判断题

##### C语言基础

(1) C语⾔中，int x>0 ,则x*x>0

> 错。可能溢出。

##### CPU指标

(2) CPI越少的机器执⾏同⼀个程序的时间越短

> 错。
> $$
> CPU执行时间=\frac{CPI*指令条数}{主频}
> $$

##### 磁盘

(3) 对机械磁盘，读取顺序存储的⽂件⽐随机存储的⽂件快

> 对。

##### 冯诺依曼

(4) 冯诺依曼是数据和指令混合存储的

> 对。显然。

##### 流水线

(5) MIPS五级流⽔线设计中，使⽤充分设置功能单元的⽅法可以改善结构冲突

> 对。结构冲突的起因是资源争用，充分设置资源的方式可以改善结构冲突。

#### 填空题

##### 补码

(1) +1234的补码为[      ] (⽤⼗六进制，⼩端表⽰)

##### 浮点数

(2) 27.625的IEEE754为[      ] (⼗六进制)

##### 数据冲突

(3) MIPS五级流水线中，解决数据冲突的方法，给出3个.[     ] [     ] [     ]

> 暂停流水线，数据旁路，编译器调度。

##### Cache

(4) 缓存缺失的类型包括，写3个（）

> 必然缺失，容量缺失，冲突缺失，无效缺失。

#### *计算题 流水线（MIPS汇编）

pc输入2ns，寄存器堆输入1ns，输出2ns，寄存器堆在一个时钟周期内可以读取两个寄存器，或者写入一个寄存器，ALU运算6ns，内存访问10ns，组成流水线用来缓存的缓存器2ns，机器采用mips五级流水线设计，分别为取指，译码 ALU 访存 写回，部分mips指令如下：

```
addu rs rt rd
subu rs rt rd
ori rs rt imm
lw rs rt imm
sw rs rt imm
beq rs rt imm
j target
```

1.如果采用单周期设计，指令和数据存储在一起，分别计算上述7条指令所需时钟周期数
2.如果采用五级流水线设计，指令和数据分开存放，上述7条指令哪一条耗时最长？哪一条最短？给出计算结果
3.（问的cpu能达到的最大主频是多少？）

### 计算机网络

#### 选择题

##### 电话网、TCP

(1) 电话⽹络和TCP⽹络的性质的⽐较（电话⽹应该是建⽴电路）

##### *蜂窝 频率复用

(2) 蜂窝移动⽹络六边形，频率840HZ，则每个点可⽤最⼤频率

> 本题题意模糊。按照相邻不干扰的原则，可得最大必须分成3组：840/3=280Hz。
>
> > [蜂窝移动网络的课件](http://www.guob.org/course/MC_Chap31.pdf)
> >
> > ![](README/1567264764118.png)
> >
> > 图中可以看出：不同的模型，相同频段的站点距离不同。（最低N可以等于3，此时同频道干扰最大，频率复用率最高）
> >
> > [移动通信的蜂窝小区划分和频率复用](https://www.maixj.net/ict/fengwoxiaoquhuafen-pinlvfuyong-7456)

##### 以太网

(3) 以太网中最短帧长1000bit，最远两点相距离100m,数据在光纤中的传播速率为2*10^8m/s,问最大发送速率
A.1Gb/s B.2Gb/s C.100Mb/s 4.200Mb/s

(4) 停等协议通信线路利用率最低的是（ ）
A. 源和目的之间距离很近，速度快
B. 源和目的之间距离很近，速度慢
C. 源和目的之间距离很远，速度快
D. 源和目的之间距离很近，速度慢

> C。

(5) CSMA/CD中，局域网传输速率

(6) TCP中，拥塞窗口大小W，最大发送段长MSS，给RTT，求平均
算出速率近似是多少

#### 简答题

##### URL

(1) 解释以下URL各部分的意义 `http://info.tsinghua.edu.cn:80/index.jsp`

> `http`：协议
>
> `info.tsinghua.edu.cn`：主机的DNS域名
>
> `80`：主机的HTTP端口号
>
> `index.jsp`：路径名
>
> > 本题的原型在《计算机网络》黑书的P502。

##### DNS

(2) 如域名info.tsinghua. edu.cn对应的ip为166.111.4.98，解释为何会发⽣如下现象：

- ①访问`http://info.tsinghua.edu.cn/index.jsp` 正常，⽽访问`http://166.111.4.98/index.jsp` 异常

- ②访问`http://166.111.4.98/index.jsp` 正常，⽽访问`http://info.tsinghua. edu.cn/index.jsp` 异常

> ①：IP地址被多个站点共享；站点禁止IP直接访问
>
> ②：DNS服务器异常
>
> > https://blog.csdn.net/wwwdc1012/article/details/51745912
> >
> > https://blog.csdn.net/weixin_30919919/article/details/96226716
> >
> > https://blog.csdn.net/Luoyeshs/article/details/83212655
> >
> > https://blog.csdn.net/gui951753/article/details/83070180

#### 子网划分

![1567015558240](README/1567015558240.png)

(1) 如图，⽹络1有100台主机，⽹络2有50台，⽹络3有20台，请将166.111.4.0/24划分给⽹络并写出路由器接⼜ip
(2) 简述AB通信时与AC通信时使⽤ARP协议的具体情况
(3) 当A发送报⽂给C时写出各个段上报⽂的源IP，⽬的IP，源MAC，⽬的MAC（⽤MAC-A,IP-A,MAC-e0等表⽰）

## 2018

### 数据结构

#### 判断题（2’*10=20’）

##### 复杂度

判断：T(n)=a>0，无论常数 a 多大，时间复杂度为 T(N)=T(n/2)+O(1)的解总是 $O(logn)$

> 我怀疑原题是T(0)=a。
>
> Q.E.D，命题为**<font color=red>真</font>**。

##### CBA算法

判断：基于 CBA 的算法对所有大小为 n 的数组时间复杂度是$Ω(nlogn)$

> 命题为**<font color=red>真</font>**。
>
> > 参考：*PPT-P119-比较树*

##### 基数排序

判断：基数排序的底层排序算法一定是稳定的

> 19年判断题。如果不稳定，基数排序本身就不正确了。命题为**<font color=red>真</font>**。

##### 堆

判断：输入随机的情况下完全二叉堆的插入平均时间是常数

> 19年判断题。命题为**<font color=red>真</font>**。

##### Splay树

判断：伸展树插入操作的分摊时间复杂度 $O(logn)$

> splay的插入操作需要借助search接口。而serach接口的分摊复杂度（双层伸展）是 $O(logn)$。
>
> 命题为**<font color=red>真</font>**。

##### 散列表

判断：对长度为 m=4k+3 素数的散列表双平方探测一定能访问其全部元素

> 命题为**<font color=red>真</font>**。
>
> > 参考：*PPT-P1052-费马双平方定理*，*习题解答-9-17*

##### KMP算法

判断：没改进的 next 算法时间复杂度也是 $O(n)$

> 19年判断题。命题为**<font color=red>真</font>**。

##### Fib查找

判断：Fib 查找时以前后黄金分割点作为轴点的常系数相同

> 显然是不同的。因为左右的查找代价不同。
>
> 命题为**<font color=blue>假</font>**。

##### *PFC编码

判断：PFC(最优前缀编码)互换不同深度节点位置一定会破坏其性质

> 题目有问题，PFC（prefix-free code）是**前缀无歧义**编码。此时，交换节点不影响性质（一定**不**会破坏其性质）。
>
> 修改题目翻译后，命题为**<font color=blue>假</font>**。

##### 二分查找

判断：任何情况下折半查找都比顺序查找快

> 假设命中元素位于首位置。
>
> 命题为**<font color=blue>假</font>**。

#### 选择题（3’*8=24’）

##### 就地算法

就地算法的空间复杂度是（）

A.O(1) B.O(n) C.忘了不重要 D.忘了不重要

> O(1)

##### RPN

对于逆波兰式 `0!1+23!4+^*56!7*8!?/-9+`的值等于 2017，则？处的运算符为

A.加号 B.减号 C.乘号 D.除号 E.乘方 F.阶乘

> 后缀表达式即逆波兰表达式。
>
> 计算一遍即可。~~计算量太大辣~~
>
> - `1 1 +  23!4+^*56!7*8!?/-9+`
> - `2 2 3 !  4+^*56!7*8!?/-9+`
> - `2 2 6 4 +  ^*56!7*8!?/-9+`
> - `2 2 10 ^  *56!7*8!?/-9+`
> - `2 2 10 ^  *56!7*8!?/-9+`
> - `2 1024 *  56!7*8!?/-9+`
> - `2048 5 6 !  7*8!?/-9+`
> - `2048 5 6! 7 *  8!?/-9+`
> - `2048 5 7! 8 !  ?/-9+`
> - `2048 5 7! 8! ?  /-9+` = 2017
> - `2048 5 7! 8! ?  /-` = 2008
> - `5 7! 8! ?  /` = 40
> - `7! 8! ? ` = 1/8
> - `?`=`/`

##### BM算法

对于长度为 m 的串进行串匹配时好后缀数组中 gs[0]=1 的概率为

![1567519159374](README/1567519159374.png)

> B。
>
> 设串为
> $$
> A_1A_2A_3...A_m
> $$
> 由gs[0]=1（只需要向左移1位），可推出，
> $$
> A_1=A_2,A_2=A_3,……,A_{m-1}=A_m
> $$
> 即，串中**所有字符全等**
> $$
> A_1A_2A_3...A_m=XXXX……XX
> $$
> 设字符集大小为T，则串中所有字符全等出现的概率为
> $$
> T*\left(\frac{1}{T}\right)^m=\left(\frac{1}{T}\right)^{m-1}=\frac{1}{T^{m-1}}
> $$
> 似乎回忆题中漏掉了字符集大小的条件。可以猜测此处T=2。故选B。

##### 非法表达式

一个非法表达式，问强行求解的值是多少

> 我猜是非法表达式指的是用evaluate求解时非法的中缀表达式。
>
> 2014期中有一道类似题：（选B，见*习题4-12*）
>
> ![1567528209788](README/1567528209788.png)

##### B树

7 阶 B-树**根节点常驻内存**，则对规模为 2017 的 B-树最多需要几次访问？

> 7阶B树 = (4,7)-B树。（B树叶节点深度相同）
>
> 为求最大访问深度，假设总不命中，取最小分支，根节点可为2分支，故
> $$
> 2*4^{d}>2017 \Longrightarrow d>5
> $$
> 故最多需要5次访问。

##### 散列表

散列长为 2017，采用单平方探测，已经存入 1000 个元素，问此时最多有（？）个**懒惰删除**的桶单元。

- A.8 B.9 C.？ D.？

>  B。2017是素数。可访问元素数=1009。因此最多有**9个**懒惰删除的桶单元。

##### *BBST

分别按照递增和递减的顺序依次向平衡二叉树插入元素，则存在常数 k 使 n=2^k-1 是二者生成的平衡二叉树相等的（？）条件。

- A.充要条件 B.必要不充分条件 C.充分不必要条件 D.不充分不必要条件

> emm。

##### 左式堆

左式堆最右侧链长度为 k，则左式堆__含有__个元素。

- A.最少 2^k B.最少 2^k-1 C.最多 ** D.最多 **

> B。最少$2^k-1$个内部节点。
>
> > 参考：*PPT-P1196*

##### *AVL

 对于同一个长度为 n 的序列分别按照递增和递减的顺序构造 AVL 树，那么“存在正整数
k，使 $n=2^k-1$ ”是“两次构造的堆相同”的（ ）
A.充分不必要条件 B. 必要不充分条件 C. 充分必要条件 D. 既不充分也不必要条件

#### 算法题

##### 单峰向量（好像是 16’）

已知 A[0,n ), A[0~k)严格单调递增，A[k~n)严格单调递减，设计一个 O(logn)算法找出 k

1)伪代码描述算法
2)说明算法正确性
3)证明最坏情况下时间复杂度也是 O(logn)

> 二分即可，每次比较左右两侧。

##### 最大和区间（好像是 10’）

给定一个整数序列，求出连续子序列和的最大值
1)说明算法思路
2)伪代码描述算法
3)说明时间复杂度和空间复杂度
题注(大致意思)：蛮力算法就不要用啦，是 O(n^3),只有设计出 O(n)算法才有可能满分，O(n^2)酌情给分。

> RT。
>
> ![1561891249167](README/1561891249167.png)

### 操作系统

#### 填空（0.5‘*10=5’）

##### 僵尸进程

1)父进程退出后，没结束的子进程变成 （）。

> 子进程执行 exit()，若未检测到父进程执行 wait()，则子进程进入__状态。当某子进程调用 exit()时唤醒父进程，将 exit()返回值作为父进程中 wait()的返回值

##### 调度算法

2)高响应比调度算法的分母是程序的（），分子是（）。

##### 优先级反置

3)优先级反置指的是（）抢占了（）的资源，（）时低优先级进程能动态改变优先级

##### 管程

4)（）支持暂时放弃互斥资源访问权，等待信号

##### 线程

5) （  ）提供了一个执行环境，其中线程只能同时执行一个 balabala

#### 判断（0.5‘*10=5’）

1)管程就是一个黑箱子，程序员往里面扔函数，同一时间只有一个函数在执行

2)Buddy算法中，释放一个空间后可以根据起始长度和大小与相邻空闲空间合并

3)如果用户强制使用任务管理器kill一个进程，那么即使它处于就绪状态/阻塞状态，操作系统也要把它变成运行状态

4)操作系统采用copy on write机制时，fork()函数会复制进程的页目录表

5)使用自旋锁不能保证进程按先来后到的顺序使用 cpu 资源

6)管程和信号量在功能上等价

7)管程将资源抽象成条件变量，通过变量值的增减来控制进程的访问

#### **belady(6’)

LRU、BEST、CLOCK、FIFO页面置换算法是否能产生belady异常，若可以举出例子，不可以给出证明

> ~~wdm，还要举例子，还要证明？？？~~。

#### ucore(6’)

![1567523276326](README/1567523276326.png)

![1567523281241](README/1567523281241.png)

![1567523285363](README/1567523285363.png)

![1567523289150](README/1567523289150.png)

le2page(*page,page_link)语句都需要展开那些宏定义？说明这个语句的含义。(还有一段ucore代码是buddy（伙伴）算法的页面分配函数，好像跟这道题关系不大，就不贴了~~主要是没找到~~。)

> 一道 Ucore 代码的题。然后列了整整三张 ucore 代码，其中一张是列表 list 的定义和add 操作，另两页是题目要用的。问最后一页的一句代码调用了几个宏命令，是什么意思

#### 哲学家就餐（4’）

![1567523480040](README/1567523480040.png)

```c
mutex = 1 //信号量，初值为 1
while(1) {
    think();
    P(mutex);
    P(左边的叉子);
    P(右边的叉子);
    eat();
    V(左边的叉子);
    V(右边的叉子);
    V(mutex);
}
```

1. 该算法是否会导致死锁，为什么？
2. 该算法是否允许两名哲学家同时用餐，为什么？若可以请举例

> ~~两版回忆，一个贴的方案1，一个贴的方案2~~。。。晕。
>
> 方案1（自由进餐）：
>
> - 会导致死锁。
>
> 方案2（互斥信号量）：
>
> - 不会导致死锁，但每次只允许1人进餐
>
> 还有个这里没提到的方案3（分奇偶）:
>
> - 没有死锁，可有多人同时进餐

#### 虚拟分页（4’）

Intel X86-32 CPU 使用分页管理，每页 4KB，逻辑地址格式如图所示，这种 CPU最多支持 4GB 内存。为了使系统能够使用 64GB 内存，使用物理内存扩展技术，使地址长度变为 64 位，页面大小仍为 4KB。试设计逻辑地址格式，使其可以在支持物理内存扩展技术的 X86-32 CPU 上运行。

![1567526730310](README/1567526730310.png)

> 1B=8bit(位)。

### 组成原理

#### 判断

##### 主频

CPU 的主频越高，指令执行的越快。

> 错。执行时间=（指令条数***CPI**）/主频。

##### RAID

raid6坏两个磁盘也可以工作

##### C语言

c语言若int x,y 若x>y，则-x<-y

> 错。反例：int的范围是[-M, M-1]。令y=-M，则-y=M=-M(溢出)，故y总是最小值。

##### 虚拟内存

内存逻辑地址连续的，物理地址不一定连续。

> 对。

#### 填空

##### 补码

1)-2017的32位补码表示（ ）(16进制或2进制)。

##### 浮点数

2)-2017.0 使用 IEEE 标准表示为单精度浮点数为（ ）（使用 16 进制获二进制表示）

##### Cache

3)Cache 和主存的映射方式：（ ），（ ），（ ）。

> 全相联映射，直接映射，组相联映射。

##### 处理机

4)处理机（ ）逻辑电路进行算术运算，（ ）逻辑电路用于数据暂存，（ ）逻辑电路用于分支选择。

> 组合，时序，组合。

#### 选择

##### 流水线

1)以下关于五段流水线的处理机说法错误的是 

A.多个处理器不会发生结构冲突 

B.每个周期执行一个功能

C.可以采用微程序或者硬连线设计

D.不同的指令执行时间相同

> A。A显然。B、D是PPT原话。C说的是CPU控制器的组成，也算对吧。

##### 缓存

2)以下说法正确的是

A.缓存越大程序执行速度越快

B.TLB也是一种缓存数据和指令的缓存器

C.

D.

> A。TLB缓存的是虚实地址的映射关系。

##### 异常

3)以下哪个不是响应异常的处理

A.保存pc  B.保存通用寄存器 C.保存异常原因  D.恢复pc

> B。不需要保存通用寄存器。

##### 数据冲突

4)以下哪种不可以解决数据冲突

A.暂停流水线 B.分支预测 C.调整指令顺序 D.数据旁路

> B。B是控制冲突的解决方法。

##### 流水线

4.五段流水线，每段10ns，每个寄存器5ns，以下一段程序(4句)，问执行时间是多少

lw ***

sub ***

and ***

or ***

### 计算机网络

#### 选择

##### OSI和TCP

1)TCP/IP与OSI 

A.

B.OSI从上到下依次是应用层，会话层，表示层，网际层，网络层，数据链路层，物理层

C.TCP/IP从上到下依次是应用层，网络层，数据链路层，物理层

D.TCP/IP适用场合比OSI更广

> D。B没有网际层，C缺失传输层。

##### 奈奎斯特定理

2)奈奎斯特定理适用于以下哪些场合 

Ⅰ光纤 Ⅱ.同轴电缆 Ⅲ.红外线

A.Ⅰ和Ⅱ     B.Ⅱ和Ⅲ     C.Ⅰ和Ⅲ     D.Ⅰ、Ⅱ、Ⅲ

> D。此题为迷惑题，奈奎斯特定理适用于任何信道（即使是理想信道）。我觉得此题的含义准确来说应该是哪些场合受到奈奎斯特定理的约束。毕竟Ⅰ、Ⅱ、Ⅲ都不是理想信道。但准确来说，此题更像是香农定理。
>
> 网上可以查到另一道题：
>
> > 奈奎斯特定理适用于光纤吗?还是只适用于铜线?
> >
> > 答:都**适用**,因为**奈奎斯特定理适用于**所有介质

##### *GBN协议

3)两地相距3000公里(传播速度6us/公里) 最大帧64字节，采用GBN协议，带宽为1.544Mbps，则若要最大限度发挥网络带宽，至少需要多少比特的序号

A.  B.  C.  D.  

> 时延带宽积=`传播时延18ms*带宽1.544Mbps`=27792bit。
>
> 最大发送帧数=`时延带宽积27792/最大帧长64*8`=54.28125
>
> 故，序号比特数>=`log(54.28125)`=6

##### 数据链路层

?. 数据链路层使用的单位是
A.比特 B.报文 C.帧 D.分组

> C。显然。

##### 选择重传协议

选择重传协议，序号为0-7，发送窗口为7，当数据发送不产生冲突（为了使传输不出错），接收窗口最大值为多少

A.4  B.5  C.7  D.8

> 

##### DNS

dns相关问题

A.天猫双12购物，不同地方两个人访问淘宝得到的ip一定相同

B. 

C.存储ip是五元组

D.数据库集中存储

#### 透明网桥（4’）

一道透明网桥的大题，两个网桥三段子网，建立转发表，要求填表。

> 网桥题，填转发表，和**王道**上的一道原题几乎一样。

#### 路由器（10’）

一道路由器大题，两个路由器，三段网络的最大帧长度分别为1024,512,912，报头长度分别为14,12,12(数据不一定准确)。

拓扑结构：A—R1—R2—B（R1、R2的e0接口分别连A、B，e1接口互连），

1）  分配给这个网络一个192.166.1.0/24的ip，划分子网，使A，B子网中主机数量尽可能多,写出子网以及R1，R2的e0、e1接口的ip地址和子网掩码

2）  现在要发送一个长度为900B的tcp数据段，tcp首部20B，ip首部20B，identification值为X，问这个数据段经过A-R1、R1-R2、R2-B三段子网的时候total_length、identification、DF、MF、offset值分别为多少(单词记得不准)

3）  A要给B发7个数据段，建立了一个TCP连接，已知往返时间为RTT，问从建立连接开始到发送结束共持续了多长时间

> 两个路由器 R1、R2，R1 的 e0 端口链接着局域网 LAN1，R2 的 e0 端口连接着局域网 LAN2，R1 的 e1 端口连接着 R2 的 e1 端口。主机 A 在 LAN1 内，主机 B在 LAN2 内。
>
> A~R1 之间的网段最多容纳的帧长一千多 B，包括 12B 的头部，R1~R2 的网段最多512B，包括 12B 的头部，R2~B 的网段最多容纳 912B，包括 12B 的头部。
>
> 1. 现在有 IP 地址 161.111.1.0/24 分给这些网，包括 R1 和 R2 的两个端口，问
> 该如何分配，才能使 LAN1 和 LAN2 所获得的 IP 地址数量之和最多，写出 LAN1、
> LAN2 的 IP 地址范围，R1、R2 的端口地址以及它们的子网掩码。（4’）
> 2. 若 A 要发送一个数据段 900B，TCP 头部 20B 的报文，在网络层加了一个 20B
> 长的 IP 分组头部，Identification 的值为 X，问这个 IP 分组在 A~R1，R1~R2，
> R2~B 上传输时，分组的 Total length、Identification、DF、MF、fragment
> offset 的值各是多少？（4’）
> 3. 若从 A 到 B 所需往返传输时间为 RTT，现在 A 要向 B 传输 7 个 TCP 报文，那么
>   从开始建立连接到 A 收到最后一个确认帧结束共经历了多少 RTT？

## 2017

### 数据结构

#### 判断题

##### 复杂度

判断：若 f(n)=时间复杂度 O(g(n)),也不一定有 f(n)=O(g(n-1)).

> 命题为**<font color=blue>假</font>**。

##### *散列表

判断：若散列表使用不超过其长度的素数，则存储关键不能保证其分布均匀。

> 假设这里的策略是除余算法。
>
> > 不太明白此题之含义。
> >
> > 参考：*教材-9.3.3-散列函数-除余法-P262*

##### *KMP算法

判断：在字符集各字符出现概率相同时，kmp 算法时间渐进程度接近蛮力算法。

> 字符集越大KMP越接近蛮力算法（或者匹配概率越小）。跟各字符的概率没有关系吧？
>
> 命题为**<font color=blue>假</font>**。

##### Huffman编码

判断：哈夫曼树距离深度更小的节点的权值可能小于深度更大的节点的权值。

> 不可能。但可能相等。
>
> 命题为**<font color=blue>假</font>**。

#### 选择题

##### Catalan数

五个互异节点构造的二叉树有多少种？

> $Catalan(5)=\cfrac{(2\times5)!}{5!\times (5+1)!}=42$。
>
> > 参考：*教材-7.3-平衡二叉树*，*习题解答-7-2*

##### 逆序数（插入排序）

对序列（64，63，...，2，1）进行直接插入排序比较次数最接近于（）
A.2800 B.2600 C.2400 D.2200 E.2000

> E。**全逆序数**=64*63/2=2016。

##### BBST

将关键字 1，2，3...，2016 插入初始为空的平衡二叉树中，假设只有一个根节点的二
叉树高度为 0，那么最终二叉树的高度是多少？

> 

##### B树

搜索 7 阶 B 树的第 2016 个关键字，假设 B 树根节点在内存中，则共需启动几次 I/O.

> 4至5次。我觉得原题应该跟18年的B树差不多。

##### 逆波兰表达式

有如下逆波兰式结果为 2016，问?中的运算符号是多少（）

```
2 0 ！ * 2 2 * 6 + ^ 18 8 ? 9 / *
```

- `A.+ B.* C.^ D. ! E./`

> 

#### 算法题

##### BFS

请利用图的广度优先遍历找出图中的**最小环**，若不存在环则输出+oo,要求时间复杂度为 O(n*e)，空间复杂度为 O(n)，最小环即环中边数最少的环。
（1）请描述你的算法思想。
（2）请用伪代码写出算法。
（3）说明你的算法的时间复杂度和空间复杂度。

> ~~关注**backward**边。环的长度等于BFS节点的深度相减。~~
>
> 打脸了，想简单了。
>
> 看到O(n*e)，立马就会做了。直接跑n遍bfs。
>
> 每一次CROSS都`if(CROSS) Ring = min(Ring, a.depth + b.depth + 1)`。每轮就能计算出经过根节点的所有环的最小环。把每一个节点依次当作根节点BFS即可。

##### *有序向量的二路归并排序

![1567515424116](README/1567515424116.png)

1）填空 merge
2）对 ABCDE 处的注释补充
3）rotate（）
4）说明这种算法的优缺点

> 回顾张奥live的题面。

##### *后序遍历

若二叉树的数据结构如下

```c++
Struct binarytree｛
    Struct binarytree*parent；
    Struct binarytree*lc；
    Struct binarytree*tc；
    Struct binarytree*first（）；
｝
Struct realbinarytree｛
    Struct binarytree p；
    Struct binarytree*next（）；
｝
```

（1）若 first()函数是取二叉树后序遍历节点的第一个节点，请写出 first（）函数代码。
（2）若 next（）函数是取该节点的后序遍历的后继，请写出 next（）函数代码。
（3）在调用 first（）函数和 next（）函数对二叉树进行后序遍历时，证明遍历时间复杂度
为 o（n）。

> 1、2问不难。

### 操作系统

#### <font color=red>多选题</font>

##### 系统调用

（1）exec（）系统调用会改变以下哪些参数（）
A.进程 ID B.父进程 ID C.文件打开指针 D.？

##### 硬件？

（2）.以下由硬件完成的是( )
A.获取中断源 B.形成中断入口地址 C。Eax 寄存器保存 D.？

##### 动态分区

4）以下算法（）会产生很多不必要的小碎片的分区
a）最佳匹配
b）首次适应
c）最坏匹配
能够有效避免产生小碎片的算法是（）
a）最佳匹配
b）首次适应
c）最坏匹配

##### 管程/线程

5）关于线程和管程错误的是（）

##### belady

7）以下会发生 belady 异常的是（）
a）FIFO 算法
b）LRU 算法
c）CLOCK 算法
d）LFU 算法
e)改进 CLOCK 算法

##### RAID

8）以下哪种磁盘阵列存取速度快（）
A.RAID0
B.RAID1
C.RAID4
D.RAID5

#### ucore

2.
1）很多代码 balabala，求 intr
2）flag，turn balabala 填一行代码

#### 虚拟存储

2.一台计算机虚拟空间 8KB，物理空间 4KB，二级页表，页表项 32B,页目录项 1B，页表大小
32B，求进程页面大小有多少 b

### 组成原理

##### 指令概念

1）指令由指令操作码和（  ）组成

> 操作数。

##### 海明码

2）若海明码 P1P2D1P4D2D3P4 为？？？？？？？？，则该海明码有（）位错误（0 位，
一位，二位），正确的 D1D2D3 为（）。

##### 总线

3）DMA 使用总线的方式为（）和（）。

> 独占总线，周期窃取。

#### 选择

##### 浮点数

IEEE 规格化单精度浮点数能表示的最小正数是（）

##### 指令的概念

（）是计算机运行的最小单位
a）？     b）微指令    c）指令    d）？

> C。PPT293页原话，`指令是计算机运行的最小功能单元`。

##### Cache计算

3.30 位虚拟地址，28 位物理地址，一级页表，页表大小 16KB，访问 5ns，cache 采用直接相
连映射，大小 64KB,块大小 4B，访问 5ns，主存访问 40ns
1）虚拟页表脏位 1 位，有效位 1 位，问页表大小
2）cache 标志位，索引位，块内地址各多少位
3）一次 cache 命中访问时间，cache 失效访问时间，命中率为 90%平均访问时间
4）系统进程切换时以下操作是否需要，原因
  a）清除 cache 有效位
  b）将已经调入页表清空
5）注意到页表访问和 cache 访问时间相同，可否通过修改 cache 映射方式，使 cache 和页表
一同访问，可以的话做出相应设计，并计算 cache90%命中率的时候的平均访问时间。

##### 流水线

4.指令流水线可能发生的冲突分类，以及原因

> 结构冲突。因为资源冲突而无法使用某种指令集合。
>
> 数据冲突。流水线中的指令序列的操作数读写顺序发生改变。
>
> 控制冲突。程序执行转移类指令而引起的冲突。

### 计算机网络

#### 选择题

##### SNMP

（1）以下关于 SNMP 协议说法错误的是（）
A.SNMP 协议具有性能管理，故障管理，配置管理，记账管理和安全管理
B.SNMP 采用 TCP 协议进行管理
C.?
D..?

#### TCP

4.太空站的 128kbps，发送 512 字节，端到端的传输延迟 300ms，确认帧长度忽略不计，接
收窗口足够大，问发送窗口分别为 1，15，27 时，吞吐率为多少？若要使信道利用率达到
最大，则帧序号至少为多少？

#### IP

5.已知有如下网络，边的权值表示花费。

> 给一个网络的表填写距离向量表和路径表，ip 地址为 200.1.5.0/24 四个局域网分别有 78，38，14，9 个主机，划分子网，每个路由器的端口，网络地址范围。

![1567516353019](README/1567516353019.png)

![1567517151516](README/1567517151516.png)

（1）若采用距离向量算法和水平分裂算法，写出 D 节点收到的信息，表格如下。

![1567517167861](README/1567517167861.png)

（2）使用 RIP 算法写出 D 收敛后的转发表，表格格式如下。

![1567517179430](README/1567517179430.png)

（3）若采用链路状态协议，写出 D 收到的链路状态，若表格中源和和目的等价，即 AB 和
BA 等价，表格格式如下。

![1567517192621](README/1567517192621.png)

（4）若局域网 1 到 4 分别有 78，38，14，4 台主机，请将网路 202.1.5.0/24 分配给图中局
域网和路由器间网段，写出划分后的网络，以及路由器端口 IP 地址及掩码。

## 2016

### 数据结构

#### 判断题

##### 地址运算

判断：指针 p 指向某一个逻辑地址，那么 p++就是访问下一个逻辑地址。

> 物理地址。命题为**<font color=blue>假</font>**。

##### 插入排序

折半插入算法在寻找插入的位置时，采用的是二分查找，因此整个折半插入算法的时间复杂度为O(n*logn).

##### 冒泡排序

在进行冒泡排序时，有可能出现某些元素在排序过程中一直远离它的最终位置.

##### *Dijkstra算法

权值都为正整数的图能否用迪佳斯特拉（算法名字有点忘了）构造出最短路径？

> 单源最短路。命题为**<font color=red>真</font>**。

#### 选择题

##### BST

二叉搜索树中最大的节点
A 仅有左孩子，没有右孩子
B 仅有右孩子，没有左孩子
C 既有左孩子，又有右孩子
D 没有左孩子，也没有右孩子

> 此题有问题。只能确定没有右孩子。

##### *栈混洗

一组输入MAMAMIAM入栈，要求出栈顺序也为MAMAMIAM。共有几种方案?

```
A.4     B.5    C.6    D.7
```

> ***以前的笔记***。
>
> 在群里遇见一个真题。
>
> > 一组输入MAMAMIAM入栈，要求出栈顺序也为MAMAMIAM。共有几种方案?
> >
> > ```
> > A.4     B.5    C.6    D.7
> > ```
>
> 解：共有11种方案。（**黑体**表示连续输出的）
>
> ```
> 可以将MAMAM**I**AM串**反向**处理为MA**I**MAMAM。	
> 
> 首先，<u>可以肯定的是</u>，*假如不进行分批次出栈，最后得到的结果是* MA**I**MAMAM。
> 
> 由于栈的特性，实际上，任何前缀子链都可以插入后面的串中。（即，先输出）
> 
> 而且，对于每一个**出栈单元**这样的交换均是独立的。
> 
> 因此，只需要**先划分，再计算排列数**就行了。
> 
> 易得，划分MA**I**MAMAM必须满足的条件：
> 
> 	①A-I-M必须分开；②必须至少有一个AM串；③排列后，**I**和某个AM串必须顺序相邻。
> ```
>
> - 如此，只有以下的划分：
>   - **M-A**-I-**M-A**-M-AM
>   - **M-A**-I-M-AM-AM
> - 考虑条件③：
>   - **M-A** - **M-A**-M-IAM
>   - **M-A**-M-AM-IAM （乘以2）
> - 考虑单元的交换：（同时考虑1-5位首尾的约束：必须是M）
>   - **M-A** - **M-A**-M-IAM
>     - **MA**-**MA**-M-IAM【1】
>     - **M-A**-**M-A**-M-IAM【4】
>   - **M-A**-M-AM-IAM 
>     - **MA**-M-AM-IAM 【1】
>     - **M-A**-M-AM-IAM 【2】
> - **因此共$1+4+2 \times(1+2)=11 $种**。
>
> *假如串是MAMAMIA*。可以同样处理。
>
> - 同理，反转为A**I**MAMAM。
> - 划分并考虑约束：
>   - **M-A-M-A-M**-IA【5】（可以从右侧开始，按单个M的提前分类讨论：1+2+2=5）
>   - A-M-**M-A-M**-IA【1】
>   - A-**M-A-M**-M-IA【1】
> - 共7种。（？？？？？）
>
> ------
>
> 算了。暂时放弃了。题真的看上去简单，做起来不知不觉就难了。
>
> 唉。
>
> ------
>
> 考研真题：http://www.cskaoyan.com/thread-594890-1-2.html
>
> ------
>
> 12.20补充：
>
> 学了邓老师的栈混洗。大概会了。
>
> 如下：（简化了一定程度，但仍然很繁琐）
>
> > MAMAMIAM编号为12345678（入栈）。
> >
> > 由于1号元素具有隔离作用，6号元素具有定位作用，故极容易指定为4种情况。
> >
> > - 1AMAM6AM
> > - MA1AM6AM
> > - MAMA16AM
> > - MAMAM6A1
> >
> > 此时，发现规律，A（247）、M（358）的自由元素均是3元组。
> >
> > - 1AMAM6AM
> >   - 分析A，共6种，724除去
> >   - 742（0），472（0），427（1），247（2），274（1）
> >   - 共4种
> > - MA**1**AM6AM
> >   - 由于1的限制，可以进一步**321**AM6AM
> >   - 共1种
> > - MAMA**1**6AM
> >   - 由于1的限制，可以进一步MAMA**1**6**78**
> >   - 3种
> > - MAMAM6A1
> >   - 由于6的限制，MAMA**8**6A1
> >     - 3A5A**8**6A1——3A57**8**6A1，2种
> >     - 5A3A**8**6A1——5A37**8**6A1，1种
> >   - 共3种
> > - **总计11种**，完毕
>
> 深夜。想到一个更加简洁的方法。
>
> > 入栈序列MAMAMIAM（12345678）。出栈序列假设为MAMAM**6**AM。
> >
> > 显然，M（1358），A（247）。很容易继续推出：（先确定极端值**8**）
> >
> > - MAMA**86A**M，**Ａ**只能是2或4
> >   - MAMA**8621**，
> >   - MAMA**8641**，MAMA**8643**
> > - MAMA**1678**，MAMA**3678**，MAMA**5678**
> > - 总共6种MAMA组合
> >   - MAMA**8621**，3**4**5**7**
> >   - MAMA**8641**，**2**35**7**
> >   - MAMA**8643，**1**2**5**7**
> >   - MAMA**1678**，**2**3**4**5
> >   - MAMA**3678**，1**24**5
> >   - MAMA**5678**，1**2**3**4**
> > - 2+1+1+3+1+3总计**11种**，但仍然比较麻烦

##### AVL树

在 AVL 树中，（）可能会发生两次旋转调整？
A 添加、删除节点操作
B 仅删除节点操作
C 仅添加节点操作
D 添加、删除节点都不

> A。教材上AVL树一节，双旋。

#### 算法题

##### 二叉树遍历

给出中序序列{D B A E C F}和层次序列{A B C D E F}能否唯一确定一颗二叉树？能给出步骤，不能的话请构造其中一棵

> 能。
>
> 对于任意一个
>
> - 中序：####…**M**####…
> - 层次：**M**########……
>
> 根据层次遍历可确定根节点在中序中的位置，则中序遍历分为左右两个子序列，从而可以递归地确定。
>
> - 中序：##…**L**##…  M  ##…**R**##…
> - 层次：M  **LR**######……
>
> 就本题而言，
>
> - D B   **<font color=red>A</font>**   E C F；**<font color=red>A</font>**   B C D E F
> - D **<font color=blue>B</font>**   **<font color=red>A</font>**   E **<font color=blue>C</font>** F；**<font color=red>A</font>**   **<font color=blue>B</font>** **<font color=blue>C</font>** D E F

##### Prim 算法

程序应该是 prim 算法，问是否能够构成最小生成树，如果能就证明，不能举出例子驳斥V 表示图的点集，U 表示已经确定路径的点集，初始时 U 为空，F 为已经确定的路径，初始也为空。先任意取一点 u 放入 U，然后在 V-U 中遍历 u 的邻接点，选权值最小的边 e 和点 v 放入 F和 U 中，具体算法就请翻书吧

> emmm

##### *重散列

散列表长为 13，采用双散列函数解决冲突：H(key) = key % 13， H’(key) = ( 7 * key % 10 ) + 1
输入顺序为 12 15 03 78 31 36（这几个数字一定有，尤其是最后一个是 36，其他记不太起来了，但是都可以通过两次三列找到合适的位置，除了 36 冲突后再散列的位置上仍然被 03 占据，所以这两个数字位置记得最清楚）
1) 构造散列表
2) 求平均（成功\失败）查找长度

##### *二叉树重建

设计一个算法，把一个中序遍历 ABCD-*+EF??(后面三个符号忘记了不过不重要)构造成如下图所示的二叉树

![1561894735192](README/1561894735192.png)

a) 描述算法思想
b) 伪代码实现

> 这也不是中序遍历啊。。明明是RPN。。
>
> 就按照中缀表达式求值的方法类似地搞一搞，遇到运算时就合并二叉树，从而建树。

##### 子数组

求一个数组A中**连续相同**数字的和**等于s**的最长子数组长度，例如A={1,1,2,1,1,1,2,1}，s=3，
则所求子数组长度为 3，要求算法时间复杂度不超过 O(n)，空间复杂度不超过 O(1)
a) 描述算法思想
b) 伪代码实现
c) 计算程序的算法复杂度。

> 比较简单。
>
> 遇到新数字k重置，否则累加，若等于s了，则更新答案为s/k。

##### *二叉树遍历

给了一个算法，问访问节点的顺序，树的样子是一颗深度为 4 的二叉树。

```c++
Typedef struct binNode{
    char data;
    struct binNode *rc,*lc;//左子树由子树
} binNode;
twist(node x){
    if(!x) return;
    if(x->rc){
        twist(x->lc->rc);
        putchar(x->data);
        twist(忘了);
        putchar(忘了);
    }
    Else{
        Twist(忘了);
        Putchar(忘了);
    }
}
```



### 操作系统

#### 判断题

> 1 是非判断，正确打 V，错误打 X（都写完两门了，这时候才说对错应该怎么表示，我前面
> 都用的汉字囧）

1)8 位 cpu 不能进行线程切换
2)忘了
3)死锁必要条件：互斥访问，占有并等待，非剥夺，循环等待
4)忘了
5)忘了

#### 多选题

##### 程序/进程

1) 程序和进程的区别
A 程序啥啥啥
B 进程啥啥啥
C 进程是动态啥啥啥
D 程序是动态啥啥啥

##### Cache

2) 忘了就记得选项 C 有些数据 cache 并不能存放 D 多核处理器共享一个高速缓存

3) 忘了
4) 忘了

#### 文件系统

3 一个文件系统采用索引结点方式存储文件，一个索引结点包括两个直接文件指针，一个一
级间接文件指针表（糟糕，忘记是索引表还是指针表了）一个存储块为 8KB，一个指针 4B，
问理论上这个文件系统能存放的最大文件是多大？用 TB+GB+MB+KB+B 表示

### 组成原理

#### 判断题

#### 选择题

#### 流水线

3 任何指令的执行部件可以抽象为一个逻辑组件和寄存器的结构，逻辑组件的延迟为 150ps，
寄存器为 10ps，示意图如下

![1567517343380](README/1567517343380.png)

逻辑部件又可以抽象为下图几个部件的组成：

![1567517355783](README/1567517355783.png)

- 1） 要形成一个 4 级流水，应该将三个寄存器安插在那些位置？问该四级流水的延迟和最大吞吐率
- 2） 为达到最大的吞吐率应该设计成几级流水？寄存器应该安插在哪些位置？问该流水的
  延迟和最大吞吐率

如果将上面的部件形成五级流水，分为取指（F），分析（D），执行（E），访存（M），写回（W）五个阶段，每个阶段占一个时钟周期，%edx, %edy %edz %edv 为寄存器

![1567517405978](README/1567517405978.png)

- 3） 以下三个指令按指令流水进行，为了获得最大吞吐率应进行哪些操作？三条指令一共用了多少个时钟周期？（每条指令所需要的上一条结果的数据都要等到上一条运算的结果
  才能进行）

```
MOV 100, %edx
MOV 200, %edy
ADD %edx, %edy(具体最后一条实在想不起来)
```

- 4） 以下四个指令按指令流水进行，为了获得最大吞吐率应进行哪些操作？四条指令一共用了多少个时钟周期？（每条指令所需要的上一条结果的数据都要等到上一条运算的结果
  才能进行）
  （程序都想不起来了囧，就记得前两条是把数字移入寄存器，第三条的执行需要前两条
  数据，最后一条需要第三条的数据）

### 计算机网络

#### 选择题

##### SMTP协议

1) SMTP 协议正确的是
A 服务器不能给客户发送邮件（记不清了）
B 客户不能接收服务器数据
C 一个 TCP 通道不能发送多封邮件
D 服务器之间不能互相传送邮件

##### HTTP协议

用户用http请求访问一个网页，网页一共有一个短文本和5个jpg图，问用户从请求连接到能看到整个网页为止共经过（）个RTT？

A8 B7 C6 D5

#### 拥塞避免（存疑）

关于拥塞避免的，A向B发送数据，阈值为16KB，MSS=1KB

- 1 A一直向B发送数据，未遇到超时情况，当A收到了ACK为8KB的报文后，拥塞窗口的大小为多少？
- 2 A一直向B发送数据，未遇到超时情况，当A收到了ACK为31KB的报文后，拥塞窗口的大小为多少？
- 3 当遇到超时后，（好像是又经过了多少RTT记不太清了）新阈值和此时窗口大小为多少

#### IP

2 一个网络路由 A 可以兼容 IPv4 和 IPv6，题目也给出了 A 的路由表，网络示意图如下：

![1567517710066](README/1567517710066.png)

1）路由 B 发 RIP 协议给 A，问 A 会把那个消息发送给 B，在发送的那条后面打√（A 有三个
接口，每个接口都给出了 ip 地址，但我想不起来了）

![1567517735369](README/1567517735369.png)

2）路由 B 和 A 交换了路由表，问 B 路由表新增的条项是啥，填入下表

![1567517751470](README/1567517751470.png)

路由 B 具有 NAT 功能，宿舍管理员因此给宿舍电脑分配了一批 ip 地址，（都是 10.9 打头的，具体想不起来），如果客户机要访问 dns 服务器，B 就会从 ip 转换池里挑出一个 ip 地址与该客户机的 IP 地址进行映射，比如将 ip 池中的 224.1.1.7（想不起来我自己编的）分配给客户机，那么其他网络就通过 224.1.1.7 访问该客户机，而不是客户机自己的 ip 地址。A 的转换
方式也是如此。

3）填写下表中 ip 数据报的源地址和目的地址，C 代表客户机，F 代表 DNS 服务器，B 代表
路由 B

![1567517791792](README/1567517791792.png)

5） 路由 B 要经过 A 来访问 IPv6 网络，问 A 中 B 的映射表项内容，只需给出一个可能项即可

![1567517811955](README/1567517811955.png)
